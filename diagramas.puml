@startuml

!pragma layout smetana
!define JAVA_STYLE

abstract class Simulator {
  + {abstract} create(file_name_args: String): Simulator
  + {abstract} listAgents(): List
  + {abstract} execute(): void
}

class SimulatorMotor {
  - time_limit: int
  - time_per_step: double
  - running: bool
  - terrain: Terrain
  + create(file_name_args: String): SimulatorMotor
  + listAgents(): List
  + execute(): void
  + shutDownSimulation(): void
  + saveResults(fileName: String): void
}

abstract class Agent {
  # id
  # steps: int
  # genotype: List<Action>
  + {abstract} create(fileNameArgs: String)
  + {abstract} observation(observation: Observation): void
  + {abstract} act(): void
  + {abstract} evaluateCurrentState(reward: double)
  + {abstract} install(sensor: Sensor): void
}

class ExplorerAgent {
  - id
  - position: tuple
  - sensor: Sensor
  - observed: set
  - behavior: set
  - path: List
  - inventory: List
  - noveltyScore: double
  - combinedFitness: double
  - step_index: int
  + create(fileNameArgs: String)
  + observation(observation: Observation): void
  + act(): void
  + evaluateCurrentState(reward: double): void
  + install(sensor: Sensor): void
  + pickUp(item: Item): void
  + run(): void
  + deliberate(): void
  + run_simulation(): void
  + calculate_objective_fitness(): int
  + mutate(rate: double): void
}

enum Action {
  MOVE_NORTH = (0, 1)
  MOVE_SOUTH = (0, -1)
  MOVE_WEST = (-1, 0)
  MOVE_EAST = (1, 0)
  ---
  + random_action(): tuple
}

abstract class Environment {
  # width: int
  # height: int
  + {abstract} observationFor(explorer: ExplorerAgent): Observation
  + {abstract} update(): void
  + {abstract} act(action: Action, agent: Agente): void
}

class Terrain {
  - width: int
  - height: int
  - solved: boolean
  - map: List[List]
  - chickens: List[Chicken]
  - eggs: List[Egg]
  - nests: List[Nest]
  - stones: List[Stone]
  + observationFor(explorer: ExplorerAgent): Observation
  + update(): void
  + act(action: Action, agent: Agent): void
  + initializeMap(numEggs: int, numNests: int, numChickens: int): void
  + isActionValid(future): boolean
}

class Observation {
  - agent_id: int
  - data: List
  + addData(data: Object): void
  + getData(): Iterator
}

class Item {
  # name: String
  # id: int
  # position: tuple
  # picked_up: boolean
  + __str__(): String
}

class Pickable {
  + pickUp(): void
  + drop(): void
}

class Nest {
  - limit: int
  - eggs: int
  + putEgg(numEggs: int): boolean
}

class Egg {
}

class Stone {
}

class Sensor {
  - grid
  - width: int
  - height: int
  - max_range: int
  + get_readings(agent_pos): Map
  + normalize_readings(readings): Map
}

class Chicken {
  - id: int
  - x: int
  - y: int
}



' Relationships
' MotorDeSimulacao --> Avaliacao : registra
'MotorDeSimulacao *-- AgenteAprendizagem : contém
'MotorDeSimulacao *-- AgentePoliticaFixa : contém
'MotorDeSimulacao --> Ambiente : gerencia

'Agent --> Action : gera
'Agent --> Ambiente : consome
'Agent <-- Observacao : recebe

'Ambiente --> Observacao : produz


Simulator <|-- SimulatorMotor : extends

Environment <|-- Terrain : extends
Terrain <-- Action

Agent <|-- ExplorerAgent : extends
ExplorerAgent <|-- Chicken

Item <|-- Pickable : extends
Pickable <|-- Egg
Pickable <|-- Stone
Item <|-- Nest


@enduml